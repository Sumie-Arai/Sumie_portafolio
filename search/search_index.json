{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"P\u00e1gina principal","text":"<p>Bienvenido \ud83d\udc4b  Soy Sumie AraiErazo \u00c9sta p\u00e1gina servir\u00e1 como repositorio para todas las pr\u00e1cticas que se lleven a cabo en este 5to semestre de ingenier\u00eda en mecatr\u00f3nica de oto\u00f1o 2025 en diversas materias.</p>"},{"location":"Proyectos4/About%20me/","title":"Sumie Arai Erazo","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"Proyectos4/About%20me/#1-quien-soy","title":"1) Quien soy?","text":"<p>Soy una estudiante foranea proveniente de Cuernavaca Morelos.Estudio ingenier\u00eda en mecatr\u00f3nica sin ningun antecedente o experiencia previa sobre robotica electronica ni progranaci\u00f3n fuera de los 4 semestres cursados de la carrera.Aspiro a crear dise\u00f1os mec\u00e1nicos y trabajar en alguna empresa para conseguir mas experiencia.</p>"},{"location":"Proyectos4/Diagramagamt/","title":"Diagrama de Gantt","text":"<p>En esta talba se observan tareaas propuestas, porcentajes de avance y fechas l\u00edmite.</p>"},{"location":"Proyectos4/Portada/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"Proyectos4/Portada/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Proyectos4/Portada/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"Proyectos4/Portada/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"Proyectos4/Portada/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Proyectos4/Portada/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"Proyectos4/Segmentacion/","title":"Segmentaci\u00f3n y codigo de porter","text":"<p>Unique de David Garc\u00eda</p> <p>Segmentaci\u00f3n y de David Garc\u00eda</p>"},{"location":"Proyectos4/Semana1/","title":"\ud83d\udcda Semana 1","text":""},{"location":"Proyectos4/Semana1/#syllabus","title":"Syllabus","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p> <p>Descargar especificaci\u00f3n (PDF) </p>"},{"location":"Proyectos4/Semana1/#nuestro-proyecto","title":"Nuestro Proyecto","text":"<p>Proyecto de Sumie Arai, David Garcia y\u00a0Rodrigo\u00a0Miranda</p>"},{"location":"Proyectos4/Semana2/","title":"Semana 2","text":""},{"location":"Proyectos4/Semana2/#historia-del-cafe-en-capsula","title":"Historia del caf\u00e9 en c\u00e1psula","text":"<p>El origen del caf\u00e9 expreso se remonta a principios del siglo XX en Italia. En 1901, Luigi Bezzera, desarroll\u00f3 un sistema para acelerar la preparaci\u00f3n del caf\u00e9 al incorporar vapor a presi\u00f3n en la cafetera. Este procedimiento no solo reduc\u00eda el tiempo de preparaci\u00f3n, sino que tambi\u00e9n produc\u00eda una bebida m\u00e1s concentrada y densa, pero no logr\u00f3 posicionar comercialmente su invento.</p> <p>En 1905, Desiderio Pavoni adquiri\u00f3 la patente de Bezzera. Con visi\u00f3n empresarial, introdujo la m\u00e1quina de expreso en el mercado italiano. Posteriormente, el desarrollo tecnol\u00f3gico continu\u00f3 en 1938, con Cremonesi, quien dise\u00f1\u00f3 una cafetera de pist\u00f3n que eliminaba el regusto a quemado derivado del uso de vapor o agua en ebullici\u00f3n y Achille Gaggia quien perfeccion\u00f3 la t\u00e9cnica al incorporar un pist\u00f3n de muelle que permit\u00eda aplicar presi\u00f3n al agua sin depender de la caldera de vapor. </p> <p>En 1961, la empresa Faema introdujo una innovaci\u00f3n clave: la m\u00e1quina de bomba el\u00e9ctrica. Este sistema hac\u00eda pasar agua a presi\u00f3n a trav\u00e9s del caf\u00e9, lo que dio origen al modelo de cafeteras de bomba, antecesoras directas de las cafeteras expreso modernas. Hacia mediados de la d\u00e9cada de 1970, el caf\u00e9 instant\u00e1neo gozaba de gran popularidad. En este contexto, el ingeniero suizo \u00c9ric Favre plante\u00f3 un nuevo desaf\u00edo: permitir que cualquier persona pudiera preparar en su hogar un expreso de calidad comparable al servido en cafeter\u00edas italianas. Favre trabaj\u00f3 en un sistema de c\u00e1psulas que denomin\u00f3 \u201cc\u00e9lula de extracci\u00f3n\u201d, cuyo dise\u00f1o concentraba los sabores y aromas del caf\u00e9. Su soluci\u00f3n t\u00e9cnica consisti\u00f3 inicialmente en una media esfera con un filtro y una membrana en la base. Posteriormente, modific\u00f3 el dise\u00f1o de manera que toda la c\u00e1psula actuara como filtro.</p>"},{"location":"Proyectos4/Semana2/#avances-tecnologicos-y-diseno","title":"Avances tecnol\u00f3gicos y dise\u00f1o","text":"<p>Inicialmente las c\u00e1psulas de aluminio en su dise\u00f1o original (1995), pesaban 2 gramos con un contenido de caf\u00e9 de 3 gramos.Ten\u00eda una forma de media esfera y una base con filtro, dise\u00f1o que aun se usa en algunos modelos de c\u00e1psula en la actualidad.</p> <p>Favre tambi\u00e9n desarroll\u00f3 un envase para la c\u00e1psula con un dise\u00f1o de alta eficiencia. Este se compone de siete capas de polipropileno, lo que garantiza la conservaci\u00f3n del caf\u00e9 al tiempo que reduce la proporci\u00f3n de material de embalaje. El envoltorio representa solo el 12% del peso total de la c\u00e1psula, siendo el resto caf\u00e9.</p> <p>El resultado fue el sistema Monodor, que marc\u00f3 un hito en la preparaci\u00f3n dom\u00e9stica de caf\u00e9 expreso. Dado el potencial comercial de esta innovaci\u00f3n, Favre y su empresa, Monodor S.A., establecieron una s\u00f3lida estrategia de protecci\u00f3n de patentes para asegurar la exclusividad de su tecnolog\u00eda.</p>"},{"location":"Proyectos4/Semana2/#nestle-estrategia","title":"Nestl\u00e9 estrategia","text":"<p>Nestl\u00e9 entr\u00f3 en este mercado con su empresa de caafeteras Nesspreso con un un inicio poco favorable. Sin embargo gracias a su estrategia de marketing con una experiencia explusiva para los consumidores, la patente sali\u00f3 a flote.</p> <p>Descarga presentaci\u00f3n (PDF)</p> <p>C\u00e1psulas de Caf\u00e9 de Sumie Arai</p>"},{"location":"Proyectos4/Semana2/#proyecto-smart-parking","title":"Proyecto Smart parking","text":"<p>Car Dealer de David Garc\u00eda</p>"},{"location":"Proyectos4/Semana2/#proyecto-smart-parking_1","title":"Proyecto Smart parking","text":"<p>Car Dealer de David Garc\u00eda</p>"},{"location":"Proyectos4/Semana3/","title":"Semana 3","text":""},{"location":"Proyectos4/Semana3/#predentacion-de-evaluacion-del-mercado","title":"Predentacion de evaluacion del mercado","text":"<p>Arai Erazo Sumie de Sumie Arai</p>"},{"location":"Proyectos4/Semana6/","title":"Semana 6","text":""},{"location":"Proyectos4/Semana6/#costos","title":"Costos","text":"<p>ostos de David Garc\u00eda</p>"},{"location":"Proyectos4/Trello/","title":"Trello","text":"<p>En este apartado se encuentran las tarjetas de tareas a realizar para el proyecto. Parece que Trello no permite la vista previa de sus p\u00e1ginas. Se adjunta el link para entrar aqu\u00ed: Tablero de Trello del proyecto</p>"},{"location":"Proyectos4/semana4/","title":"Semana 4","text":""},{"location":"Proyectos4/semana4/#importancia-de-nuestro-proyecto","title":"Importancia de nuestro proyecto","text":"<p>Estacionamiento Inteligente de Sumie Arai</p>"},{"location":"Proyectos4/semana5/","title":"Semana 5","text":""},{"location":"Proyectos4/semana5/#segmentacion-de-meercado-y-fuerzas-de-porter","title":"Segmentaci\u00f3n de meercado y Fuerzas de porter","text":"<p>Segmentaci\u00f3n y de David Garc\u00eda y Sumie Arai Erazo</p>"},{"location":"Sistemas%20Embebidos/1microcontroladores/","title":"\ud83d\udcda TAREA 1","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"Sistemas%20Embebidos/1microcontroladores/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Comparaci\u00f3n de microcontroladores </li> <li>Equipo / Autor(es): Sumie Arai </li> <li>Curso / Asignatura: Sistemas Embebidos 1 </li> <li>Fecha: 25/06/2025 </li> <li>Descripci\u00f3n breve: Se realiza una breve investigaci\u00f3n y comparaci\u00f3n de 4 microcontroladores que se planean utilizar para un proyecto hipot\u00e9tico en el que se construir\u00e1 un robot aut\u00f3mata que sepa bailar vals. </li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Sistemas%20Embebidos/1microcontroladores/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Tener un conocimiento m\u00e1s amplio sobre los distintos microcontroladores y sus caracter\u00edsticas individuales y ventajas para futuros proyectos. </li> <li>Espec\u00edficos:</li> <li>Familiarizarse con las herramientas gratuitas que GitHub ofrece, como esta p\u00e1gina.</li> <li>Adquirir un mejor entendimiento sobre los componentes de un microcontrolador.</li> </ul>"},{"location":"Sistemas%20Embebidos/1microcontroladores/#microcontroladores","title":"MICROCONTROLADORES","text":""},{"location":"Sistemas%20Embebidos/1microcontroladores/#1-arduino-mega-atmega2560","title":"1) Arduino Mega (ATmega2560)","text":"<ul> <li>Pines / Perif\u00e9ricos: 54 GPIO, 16 entradas anal\u00f3gicas, UART, SPI, I\u00b2C </li> <li>Memoria: 256 KB Flash, 8 KB SRAM </li> <li>Ecosistema / Lenguaje: Arduino IDE (C/C++) </li> <li>Costos: $20-30 USD aprox. </li> <li>Arquitectura: AVR 8-bit </li> <li>Velocidad: 16 MHz </li> <li>Descripci\u00f3n breve: Muchos pines para servos o sensores. Muy usado en rob\u00f3tica educativa, f\u00e1cil de programar, pero limitado en velocidad. </li> </ul>"},{"location":"Sistemas%20Embebidos/1microcontroladores/#2-esp32","title":"2) ESP32","text":"<ul> <li>Pines / Perif\u00e9ricos: 34 GPIO, ADC, PWM, UART, SPI, I\u00b2C, Wi-Fi, BT </li> <li>Memoria: 4 MB Flash, 520 KB SRAM </li> <li>Ecosistema / Lenguaje: Arduino IDE, ESP-IDF, MicroPython </li> <li>Costos: $5-10 USD aprox. </li> <li>Arquitectura: Xtensa LX6 (32-bit) </li> <li>Velocidad: Dual-core 240 MHz </li> <li>Descripci\u00f3n breve: Alta velocidad y conectividad. Permite sincronizar baile con m\u00fasica v\u00eda Bluetooth o Wi-Fi. Menos pines que el Mega, pero muy potente. Puede programarse en Arduino o Python, lo que da facilidad de uso. </li> </ul>"},{"location":"Sistemas%20Embebidos/1microcontroladores/#3-stm32f4-cortex-m4","title":"3) STM32F4 (Cortex-M4)","text":"<ul> <li>Pines / Perif\u00e9ricos: Var\u00eda: ~50+ GPIO, ADC, DAC, timers, CAN, SPI, I\u00b2C, UART </li> <li>Memoria: 1 MB Flash, 192 KB RAM </li> <li>Ecosistema / Lenguaje: STM32CubeIDE, Arduino core, C/C++ </li> <li>Costos: $15-30 USD aprox. </li> <li>Arquitectura: ARM Cortex-M4 </li> <li>Velocidad: Hasta 180 MHz </li> <li>Descripci\u00f3n breve: Potente y con hardware para control en tiempo real. Muy usado en rob\u00f3tica profesional, aunque con mayor curva de aprendizaje. </li> </ul>"},{"location":"Sistemas%20Embebidos/1microcontroladores/#4-teensy-41-cortex-m7","title":"4) Teensy 4.1 (Cortex-M7)","text":"<ul> <li>Pines / Perif\u00e9ricos: ~55 GPIO, PWM, CAN, USB host, SPI, I\u00b2C, UART </li> <li>Memoria: 8 MB Flash, 1 MB RAM </li> <li>Ecosistema / Lenguaje: Arduino IDE, C/C++ </li> <li>Costos: $30-40 USD aprox. </li> <li>Arquitectura: ARM Cortex-M7 </li> <li>Velocidad: 600 MHz </li> <li>Descripci\u00f3n breve: Alt\u00edsima velocidad y memoria \u2192 excelente para rutinas complejas de movimiento y audio. Buena integraci\u00f3n con Arduino. </li> </ul>"},{"location":"Sistemas%20Embebidos/1microcontroladores/#conclusiones","title":"Conclusiones","text":"<ul> <li>STM32F4: Es bastante utilizado para robotica y control en tiempo real. Tiene timers que facilitan el control de servos. Su arquitectura de FPU es util para calcular trayectorias.El precio es un poco elevado pero aun accesible. Es comunmente utilizado para drones por lo que tiene un buen tiempo de reacci\u00f3n. En conclusi\u00f3n parece ser la opci\u00f3n mas apta para este proyecto</li> </ul>"},{"location":"Sistemas%20Embebidos/2outputsbasicos/","title":"\ud83d\udcda TAREA 2","text":""},{"location":"Sistemas%20Embebidos/2outputsbasicos/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Outputs B\u00e1sicos </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 7/31/25 </li> <li>Descripci\u00f3n breve: En esta practica se formul\u00f3 un c\u00f3digo simple que mande una se\u00f1al de high para prender 5 LEDs uno por uno de forma que se vea un patr\u00f3n de rebote de encendido en la tira de LEDs.</li> </ul>"},{"location":"Sistemas%20Embebidos/2outputsbasicos/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Crear codigos que contengan imputs y outputs</li> <li>Espec\u00edficos:</li> <li>Aprender a prender pines de pi pico con C SDK</li> <li>Documentar progreso en p\u00e1gina de GitHub</li> </ul>"},{"location":"Sistemas%20Embebidos/2outputsbasicos/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: 5 LEDs, 2 botones, un pi pico 2, programa en C SDK.</li> <li>No incluye: Resistencias :b.</li> </ul>"},{"location":"Sistemas%20Embebidos/2outputsbasicos/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/2outputsbasicos/#5-codigos","title":"5) C\u00f3digos","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n#include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n\n#define P1 4 // BOT\u00d3N de Jugador 1\n#define P2 5 // BOT\u00d3N de Jugador 2\n#define Led1 6\n#define Led2 7\n#define Led3 8\n#define Led4 9\n#define Led5 10\n\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5)); // Configura los pines como salida\n\n\n    int posicion = 6;\n\n    int direccion = 1; // 1 para derecha, -1 para izquierda\n\n    while (true)\n    {\n        gpio_put_masked(Mascara, (1u &lt;&lt; posicion)); // Enciende el LED en la posici\u00f3n actual\n        sleep_ms(200);                             // Pausa de 200 ms\n\n        posicion += direccion; // Actualiza la posici\u00f3n\n        if (posicion == Led5) direccion = -1;\n        else if (posicion == Led1) direccion = 1;\n\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/2outputsbasicos/#6-esquematico","title":"6) Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/2outputsbasicos/#7-video","title":"7) Video","text":""},{"location":"Sistemas%20Embebidos/3inputs/","title":"\ud83d\udcda TAREA 3","text":""},{"location":"Sistemas%20Embebidos/3inputs/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Inputs </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 7/31/25 </li> <li>Descripci\u00f3n breve: En esta practica se utilizan m\u00e1scaras para recrear compuertas l\u00f3gicas en pi pico con C SDK, con dos inputs con resistencias pull-up. Adem\u00e1s de un c\u00f3digo que controla 5 LEDs que se prenden uno por uno en orden y avanza la secuencia o retrocede cada que se pica un boton de avance u otro de retroceso.</li> </ul>"},{"location":"Sistemas%20Embebidos/3inputs/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Crear codigos que contengan imputs y outputs</li> <li>Espec\u00edficos:</li> <li>Aprender a usar resistencias pull-up</li> <li>Simular compuertas l\u00f3gicas con m\u00e1scaras</li> <li>Documentar progreso en p\u00e1gina de GitHub</li> </ul>"},{"location":"Sistemas%20Embebidos/3inputs/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: 5 LEDs, 2 botones, un pi pico 2, programa en C SDK.</li> <li>No incluye: Resistencias :b.</li> </ul>"},{"location":"Sistemas%20Embebidos/3inputs/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/3inputs/#5-codigos","title":"5) C\u00f3digos","text":""},{"location":"Sistemas%20Embebidos/3inputs/#compuerta-and-or-y-xor","title":"Compuerta AND, OR y XOR","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n// #include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n#define BotonX 4\n#define BotonY 5\n#define LedX 6\n#define LedY 7\n#define LedZ_AND 8\n#define LedZ_OR 9\n#define LedZ_XOR 10\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; BotonX | 1u &lt;&lt; BotonY | 1u &lt;&lt; LedX | 1u &lt;&lt; LedY | 1u &lt;&lt; LedZ_AND | 1u &lt;&lt; LedZ_OR | 1u &lt;&lt; LedZ_XOR);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (0u &lt;&lt; BotonX | 0u &lt;&lt; BotonY | 1u &lt;&lt; LedX | 1u &lt;&lt; LedY | 1u &lt;&lt; LedZ_AND | 1u &lt;&lt; LedZ_OR | 1u &lt;&lt; LedZ_XOR)); // Configura los pines como salida\n    gpio_pull_up(BotonX);                                                                                                                    // Activa la resistencia pull-up interna del pin 4\n    gpio_pull_up(BotonY);\n\n    while (true)\n    {\n        int Entrada_X = !gpio_get(BotonX);\n        int Entrada_Y = !gpio_get(BotonY);\n        int Salida_AND, Salida_OR, Salida_XOR;\n\n        Salida_AND = Entrada_X &amp; Entrada_Y; // Pin 8 = Pin 4 AND Pin 5\n        Salida_OR = Entrada_X | Entrada_Y;  // Pin 9 = Pin 4 OR Pin 5\n        Salida_XOR = Entrada_X ^ Entrada_Y; // Pin 10 = Pin 4 XOR Pin 5\n\n        gpio_put_masked(Mascara, (1 &lt;&lt; 11) | (Entrada_X &lt;&lt; LedX) | (Entrada_Y &lt;&lt; LedY) | (Salida_AND &lt;&lt; LedZ_AND) | (Salida_OR &lt;&lt; LedZ_OR) | (Salida_XOR &lt;&lt; LedZ_XOR));\n        sleep_ms(100); // Pausa de 100 ms\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/3inputs/#secuencia-leds","title":"Secuencia LEDs","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n// #include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n#define BotonX 4\n#define BotonY 5\n#define LedX 6\n#define LedY 7\n#define LedZ_AND 8\n#define LedZ_OR 9\n#define LedZ_XOR 10\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; BotonX | 1u &lt;&lt; BotonY | 1u &lt;&lt; LedX | 1u &lt;&lt; LedY | 1u &lt;&lt; LedZ_AND | 1u &lt;&lt; LedZ_OR | 1u &lt;&lt; LedZ_XOR);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (0u &lt;&lt; BotonX | 0u &lt;&lt; BotonY | 1u &lt;&lt; LedX | 1u &lt;&lt; LedY | 1u &lt;&lt; LedZ_AND | 1u &lt;&lt; LedZ_OR | 1u &lt;&lt; LedZ_XOR)); // Configura los pines como salida\n    gpio_pull_up(BotonX);                                                                                                                    // Activa la resistencia pull-up interna del pin 4\n    gpio_pull_up(BotonY);\n\n    int posicion = 6;\n    bool presionado = false;\n\n    while (true)\n    {\n        int Boton_Izq = !gpio_get(BotonX);\n        int Boton_Der = !gpio_get(BotonY);\n\n        if (Boton_Izq == 1 &amp;&amp; presionado == false)\n        {\n            presionado = true;\n            if (posicion == 6)\n                posicion = 11;\n            posicion--;\n        }\n        if (Boton_Der == 1 &amp;&amp; presionado == false)\n        {\n            presionado = true;\n            if (posicion == 10)\n                posicion = 5;\n            posicion++;\n        }\n        if (Boton_Izq == 0 &amp;&amp; Boton_Der == 0)\n            presionado = false;\n        gpio_put_masked(Mascara, (1u &lt;&lt; posicion)); // Enciende el LED en la posici\u00f3n actual\n        sleep_ms(10);                              // Pausa de 100 ms\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/3inputs/#6-esquematico","title":"6) Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/3inputs/#7-video","title":"7) Video","text":""},{"location":"Sistemas%20Embebidos/3inputs/#compuertas-and-or-y-xor","title":"Compuertas AND, OR y XOR","text":""},{"location":"Sistemas%20Embebidos/3inputs/#secuencia-de-leds-adelante-y-atras","title":"Secuencia de LEDs adelante y atr\u00e1s","text":""},{"location":"Sistemas%20Embebidos/4pingpong/","title":"\ud83d\udcda TAREA 4","text":""},{"location":"Sistemas%20Embebidos/4pingpong/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Ping Pong </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 09/04/25 </li> <li>Descripci\u00f3n breve: Se reutiliza el c\u00f3digo de barrido de la tarea 2 para convertirla en un juego de Ping Pong que incluye dos botones, uno por jugador, donde para rebotar la pelota se debe de presionar el  boton del jugador en el momento en el que se prenda el link de la ezquina del jugador. Al iniciar el jugador que pique el boton primero es quien \"lanza\" la pelota yendo la direccion hacia el jugador contrario, al ganar un jugador, durante las siguiente ronda la direccion iniciar\u00e1 hacia este.</li> </ul>"},{"location":"Sistemas%20Embebidos/4pingpong/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Usar IRQs</li> <li>Espec\u00edficos:</li> <li>Crear una ISR</li> <li>Usar cantidades peligrosas de LEDs TuT</li> <li>Documentar progreso en p\u00e1gina de GitHub</li> </ul>"},{"location":"Sistemas%20Embebidos/4pingpong/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: 5 LEDs, 2 botones, un pi pico 2, programa en C SDK.</li> <li>No incluye: Resistencias :b.</li> </ul>"},{"location":"Sistemas%20Embebidos/4pingpong/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/4pingpong/#5-codigo","title":"5) C\u00f3digo","text":"<pre><code>// tarea4.c\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n// Pines\n#define P1 4\n#define P2 5\n#define WIN1 6\n#define LED1 7\n#define LED2 8\n#define LED3 9\n#define LED4 10\n#define LED5 11\n#define WIN2 12\n\n// Flags de interrupci\u00f3n\nvolatile bool flag_p1 = false;\nvolatile bool flag_p2 = false;\n\n// Funci\u00f3n para parpadear LED ganador\nvoid parpadear_led(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\n// Callback de interrupci\u00f3n\nvoid gpio_callback(uint gpio, uint32_t events) {\n    if (events &amp; GPIO_IRQ_EDGE_RISE) {\n        if (gpio == P1) flag_p1 = true;\n        else if (gpio == P2) flag_p2 = true;\n    }\n}\n\nint main() {\n    // Inicializar LEDs\n    const uint32_t LED_MASK = (1u &lt;&lt; WIN1) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) |\n                               (1u &lt;&lt; LED4) | (1u &lt;&lt; LED5) | (1u &lt;&lt; WIN2);\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_masked(LED_MASK, LED_MASK);\n\n    // Inicializar botones\n    gpio_init(P1); gpio_set_dir(P1, GPIO_IN); gpio_pull_down(P1); //tambien tiene pulldown externo\n    gpio_init(P2); gpio_set_dir(P2, GPIO_IN); gpio_pull_down(P2);\n    gpio_set_irq_enabled_with_callback(P1, GPIO_IRQ_EDGE_RISE, true, &amp;gpio_callback);\n    gpio_set_irq_enabled(P2, GPIO_IRQ_EDGE_RISE, true);\n\n    int ultima_direccion = 1; // 1: derecha (jugador 2), -1: izquierda (jugador 1)\n    bool primer_jugada = true; // &lt;--- NUEVO\n\n    while (true) {\n        gpio_put_masked(LED_MASK, 0); // Apagar todos los LEDs\n        gpio_put(LED3, 1); // Encender LED3 del medio\n\n        // Esperar a que se presione cualquier bot\u00f3n antes de iniciar la secuencia\n        while (gpio_get(P1) == 0 &amp;&amp; gpio_get(P2) == 0) {\n            sleep_ms(10);\n        }\n\n        // Apagar LED3 antes de iniciar la secuencia\n        gpio_put(LED3, 0);\n\n        int direccion_inicial;\n        if (primer_jugada) {\n            // Primera jugada: direcci\u00f3n hacia el jugador que NO presion\u00f3 el bot\u00f3n\n            if (gpio_get(P1) == 1) {\n                direccion_inicial = 1;  // P1 presion\u00f3, va hacia P2\n            } else if (gpio_get(P2) == 1) {\n                direccion_inicial = -1; // P2 presion\u00f3, va hacia P1\n            } else {\n                direccion_inicial = ultima_direccion; // Por si acaso\n            }\n            primer_jugada = false;\n        } else {\n            // Siguientes jugadas: direcci\u00f3n hacia el ganador anterior\n            direccion_inicial = ultima_direccion;\n        }\n\n        int posicion = LED3;\n        int direccion = direccion_inicial;\n        flag_p1 = false;\n        flag_p2 = false;\n\n        int prev_p1 = 1, prev_p2 = 1;\n\n        while (1) {\n            gpio_put_masked(LED_MASK, 0);\n\n            if (posicion &gt;= LED1 &amp;&amp; posicion &lt;= LED5) {\n                gpio_put(posicion, 1);\n            }\n            sleep_ms(400);\n\n            int curr_p1 = gpio_get(P1);\n            int curr_p2 = gpio_get(P2);\n\n            if (posicion == LED1 &amp;&amp; prev_p1 == 1 &amp;&amp; curr_p1 == 0) {\n                direccion = 1;\n            } else if (posicion == LED5 &amp;&amp; prev_p2 == 1 &amp;&amp; curr_p2 == 0) {\n                direccion = -1;\n            }\n\n            prev_p1 = curr_p1;\n            prev_p2 = curr_p2;\n\n            // Verificar victoria\n            if (posicion == WIN1) {\n                gpio_put_masked(LED_MASK, 0);\n                parpadear_led(WIN2);\n                ultima_direccion = 1; // Ahora la siguiente ronda va hacia jugador 2\n                break;\n            } else if (posicion == WIN2) {\n                gpio_put_masked(LED_MASK, 0);\n                parpadear_led(WIN1);\n                ultima_direccion = -1; // Ahora la siguiente ronda va hacia jugador 1\n                break;\n            }\n\n            posicion += direccion;\n        }\n        sleep_ms(500); // Espera antes de reiniciar el juego\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/4pingpong/#6-esquematico","title":"6) Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/4pingpong/#7-video","title":"7) Video","text":""},{"location":"Sistemas%20Embebidos/5medida/","title":"\ud83d\udcda TAREA 5","text":""},{"location":"Sistemas%20Embebidos/5medida/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Medida de error </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 09/04/25 </li> <li>Descripci\u00f3n breve: Simular una onda sinusoidal con un filtro y observar el cambio en su frecuencia.</li> </ul>"},{"location":"Sistemas%20Embebidos/5medida/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Usar IRQs</li> <li>Espec\u00edficos:</li> <li>Crear una ISR</li> <li>Usar cantidades peligrosas de LEDs TuT</li> <li>Documentar progreso en p\u00e1gina de GitHub</li> </ul>"},{"location":"Sistemas%20Embebidos/5medida/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: 5 LEDs, 2 botones, un pi pico 2, programa en C SDK.</li> <li>No incluye: Resistencias :b.</li> </ul>"},{"location":"Sistemas%20Embebidos/5medida/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/5medida/#5-codigo","title":"5) C\u00f3digo","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 6\nstatic const int BLINK_MS = 100;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/5medida/#6-foto-de-osciloscpio","title":"6) Foto de osciloscpio","text":"<p>Inicio de Sumie Arai</p>"},{"location":"Sistemas%20Embebidos/6alarma/","title":"\ud83d\udcda TAREA 6","text":""},{"location":"Sistemas%20Embebidos/6alarma/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Alarmas </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 09/04/25 </li> <li>Descripci\u00f3n breve: Crear 2 codigos: uno donde cada alarma del 0-4 controla un LED distinto con un periodo propio. Y modificar ping pong para aumentar o disminuir velocidad mediante 2 botones adicionales</li> </ul>"},{"location":"Sistemas%20Embebidos/6alarma/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Usar IRQs</li> <li>Espec\u00edficos:</li> <li>Crear una ISR</li> <li>Usar cantidades peligrosas de LEDs TuT</li> <li>Documentar progreso en p\u00e1gina de GitHub</li> </ul>"},{"location":"Sistemas%20Embebidos/6alarma/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: 5 LEDs, 2 botones, un pi pico 2, programa en C SDK.</li> <li>No incluye: Resistencias :b.</li> </ul>"},{"location":"Sistemas%20Embebidos/6alarma/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/6alarma/#5-codigos","title":"5) C\u00f3digos","text":""},{"location":"Sistemas%20Embebidos/6alarma/#codigo-1-que-debia-de-fincionar","title":"codigo 1 que debia de fincionar","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     6   \n#define LED1_PIN     7\n#define LED2_PIN     8\n#define LED3_PIN     9                     \n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n#define ALARM3_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM3_NUM)\n\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us, next2_us, next3_us;\nstatic const uint32_t INTERVALO0_US = 250u;\nstatic const uint32_t INTERVALO1_US = 400u;\nstatic const uint32_t INTERVALO2_US = 500u;\nstatic const uint32_t INTERVALO3_US = 800u;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\n// ISR para ALARM2\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\n// ISR para ALARM3\nstatic void on_alarm3_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM3_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n    next3_us += INTERVALO3_US;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n}\n\nint main() {\n\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n    gpio_init(LED3_PIN);\n    gpio_set_dir(LED3_PIN, GPIO_OUT);\n    gpio_put(LED3_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    // Programa ambas alarmas\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n    irq_set_exclusive_handler(ALARM3_IRQ, on_alarm3_irq);\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Habilita ambas IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n    irq_set_enabled(ALARM3_IRQ, true);\n\n    // Bucle principal: todo el parpadeo ocurre en las ISRs\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/6alarma/#6-esquematico","title":"6) Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/6alarma/#7-video","title":"7) Video","text":""},{"location":"Sistemas%20Embebidos/7PWM/","title":"\ud83d\udcda TAREA 7","text":""},{"location":"Sistemas%20Embebidos/7PWM/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Control de PWM </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 30/09/25 </li> <li>Descripci\u00f3n breve: _Se crean tres c\u00f3digos distintos, uno para controlar un motor DC con 3 velocidades, otro para crear frecuencias que formen una melod\u00eda con un buzzer, y otro para _</li> </ul>"},{"location":"Sistemas%20Embebidos/7PWM/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Aprender las utilidades del PWM</li> <li>Espec\u00edficos:</li> <li>Crear una supuesta variacion de voltaje mediante variaciones de duty cycles</li> <li>Utilizar frecuencias espec\u00edficas para hacer notas musicales</li> <li>Crear una se\u00f1al sinusoidal a parir de una PWM y un filtro con capacitor y leerla con un osciloscopio</li> </ul>"},{"location":"Sistemas%20Embebidos/7PWM/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>1 capacitor de 1uF, resistencias de 1k y 680 ohms, osciloscopio   -1 buzzer pasivo, 1 resistencia de 220.   -2 botones, resistencias pulldown de 1k, 1 motor DC._</li> </ul>"},{"location":"Sistemas%20Embebidos/7PWM/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/7PWM/#5-codigos","title":"5) C\u00f3digos","text":"<p>Control de velocidad de motor</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define ENA 2     // PWM para velocidad\n#define IN1 3     // Direcci\u00f3n\n#define IN2 4     // Direcci\u00f3n\n#define BTN_UP 14   // Bot\u00f3n para subir velocidad\n#define BTN_DOWN 15 // Bot\u00f3n para bajar velocidad\n\n#define F_PWM_HZ 2000\n#define TOP 1023\n\n// Velocidades en porcentaje\nconst uint8_t speed_percent[] = {40, 60, 80}; \nint speed_index = 1; // Comienza en velocidad media\n\n// Guardar estado previo de botones\nbool last_up = true;\nbool last_down = true;\n\n// Funci\u00f3n: establece velocidad con \"kickstart\" si es necesario\nvoid set_motor_speed(uint slice, uint chan, uint8_t percent) {\n    uint16_t level = (percent * TOP) / 100;\n\n    if (percent &gt; 0 &amp;&amp; percent &lt;= 40) {\n        // Arranque forzado al 100% por 100 ms\n        pwm_set_chan_level(slice, chan, TOP);\n        sleep_ms(100);\n    }\n\n    pwm_set_chan_level(slice, chan, level);\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configurar pines de direcci\u00f3n (gira siempre en un sentido)\n    gpio_init(IN1); gpio_set_dir(IN1, GPIO_OUT); gpio_put(IN1, 1);\n    gpio_init(IN2); gpio_set_dir(IN2, GPIO_OUT); gpio_put(IN2, 0);\n\n    // Configurar botones con resistencias pull-up internas\n    gpio_init(BTN_UP); gpio_set_dir(BTN_UP, GPIO_IN); gpio_pull_up(BTN_UP);\n    gpio_init(BTN_DOWN); gpio_set_dir(BTN_DOWN, GPIO_IN); gpio_pull_up(BTN_DOWN);\n\n    // Configurar PWM en pin ENA\n    gpio_set_function(ENA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(ENA);\n    uint chan  = pwm_gpio_to_channel(ENA);\n\n    float f_clk = 125000000.0f; // clock de la Pico\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    // Iniciar en velocidad media\n    set_motor_speed(slice, chan, speed_percent[speed_index]);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        bool up_now = gpio_get(BTN_UP);\n        bool down_now = gpio_get(BTN_DOWN);\n\n        // Detectar flanco de bajada con debounce\n        if (last_up &amp;&amp; !up_now) {\n            sleep_ms(50); // debounce\n            if (!gpio_get(BTN_UP)) {\n                if (speed_index &lt; 2) speed_index++;\n                set_motor_speed(slice, chan, speed_percent[speed_index]);\n            }\n        }\n\n        if (last_down &amp;&amp; !down_now) {\n            sleep_ms(50); // debounce\n            if (!gpio_get(BTN_DOWN)) {\n                if (speed_index &gt; 0) speed_index--;\n                set_motor_speed(slice, chan, speed_percent[speed_index]);\n            }\n        }\n\n        last_up = up_now;\n        last_down = down_now;\n\n        sleep_ms(10);\n    }\n}\n</code></pre> <p>Frecuencias de una melod\u00eda reconocible</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZZER_PIN 2\n#define TOP 2048\n\n// Notas de TU melod\u00eda\n#define FAs 740.0f\n#define RE  587.0f  \n#define SI  494.0f\n#define MI  659.0f\n#define SOLs 831.0f\n#define LA  880.0f\n#define DOs 988.0f\n\n// Duraciones\n#define CORCHEA 214 //duraci\u00f3n de una nota en ms, corchea es nota musical \n#define SILENCIO 214  // Los espacios son silencios de 214ms\n#define SILENCIO_MENOR 50 //Silencio de 50ms\n\nvoid tocar_nota(uint slice, uint chan, float frecuencia, int duracion) {\n    if (frecuencia &gt; 1.0f) {\n        float f_clk = 125000000.0f;\n        float div = f_clk / (frecuencia * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, TOP / 2);\n        sleep_ms(duracion);\n        pwm_set_chan_level(slice, chan, 0);\n    }\n    sleep_ms(10); // Peque\u00f1a pausa entre notas\n}\n\nvoid tocar_silencio(int duracion) {\n    sleep_ms(duracion);\n} //duraci\u00f3n de silencio\n\nvoid tocar_melodia(uint slice, uint chan) {\n    // FA#FA#RESI\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, RE, CORCHEA);\n    tocar_nota(slice, chan, SI, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // SI\n    tocar_nota(slice, chan, SI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    //MI\n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // MI \n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    // MI SOL# LA DO#\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, SOLs, CORCHEA);\n    tocar_nota(slice, chan, SOLs, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, DOs, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO_MENOR);\n\n    // LALA LAMI\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, RE, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // FA#FA#\n    tocar_nota(slice, chan, FAs, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, FAs, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(BUZZER_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZZER_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, TOP / 2);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        tocar_melodia(slice, chan);\n        sleep_ms(2000); // Pausa larga antes de repetir\n    }\n}\n</code></pre> <p>Onda cuadrada de PWM a sinusoidal con capacitor</p> <pre><code>// pwm_seno.c \u2014 Generar seno 60 Hz con PWM en GPIO 3\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PIN_PWM    3\n#define FREQ_PWM   2000     // 2 kHz portadora\n#define TOP        1023     // 10 bits de resoluci\u00f3n\n#define FREQ_SENO  60       // Se\u00f1al deseada: 60 Hz\n\n#define PI 3.141592653589793\n\n// N\u00famero de muestras por ciclo de seno\n#define N_MUESTRAS 100\n\nuint16_t tabla_seno[N_MUESTRAS];\n\nint main() {\n    stdio_init_all();\n\n    // --- Generar tabla seno ---\n    for (int i = 0; i &lt; N_MUESTRAS; i++) {\n        float ang = 2 * PI * i / N_MUESTRAS;\n        float val = (sinf(ang) + 1.0f) / 2.0f;  // [0,1]\n        tabla_seno[i] = (uint16_t)(val * TOP);\n    }\n\n    // --- Configuraci\u00f3n PWM ---\n    gpio_set_function(PIN_PWM, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PIN_PWM);\n    uint chan  = pwm_gpio_to_channel(PIN_PWM);\n\n    float f_clk = 125000000.0f; // 125 MHz\n    float div = f_clk / (FREQ_PWM * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n    // --- Temporizaci\u00f3n para 60 Hz ---\n    // Cada ciclo = 16.67 ms. Dividido en N_MUESTRAS \u2192 periodo de actualizaci\u00f3n:\n    float Ts_ms = 1000.0f / (FREQ_SENO * N_MUESTRAS); // ~0.167 ms (167 \u00b5s)\n\n    int idx = 0;\n    while (true) {\n        pwm_set_chan_level(slice, chan, tabla_seno[idx]);\n        idx = (idx + 1) % N_MUESTRAS;\n        sleep_us((int)(Ts_ms * 1000));\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/7PWM/#6-esquematicos","title":"6) Esquem\u00e1ticos","text":"<p>Circuito del motor</p> Pico (GPIO) Pin f\u00edsico Pico Conecta a Nota GP2 4 Puente H \u2192 ENA PWM para velocidad GP3 5 Puente H \u2192 IN1 Direcci\u00f3n GP4 6 Puente H \u2192 IN2 Direcci\u00f3n GP14 19 Bot\u00f3n 1 Subir velocidad GP15 20 Bot\u00f3n 2 Bajar velocidad GND 3 GND com\u00fan Pico + Puente H + botones Motor DC \u2013 Puente H \u2192 OUT1/OUT2 Salidas del puente H VIN externa \u2013 Puente H \u2192 VIN Fuente de motor (no Pico) Bot\u00f3n 1 \u2013 Pull-down \u2192 GND Estabiliza se\u00f1al Bot\u00f3n 2 \u2013 Pull-down \u2192 GND Estabiliza se\u00f1al <p>Circuito de buzzer</p> <p>Circuito de se\u00f1al de PWM sinusoidal</p> <ul> <li>_Nota: No existen los capacitores en wokwi, el led que se muestra reemplaza el capacitor. La se\u00f1al se toma del cable morado hacia el osciloscopio.</li> </ul>"},{"location":"Sistemas%20Embebidos/7PWM/#7-video","title":"7) Video","text":""},{"location":"Sistemas%20Embebidos/8comunicacionuart/","title":"\ud83d\udcda TAREA 8","text":""},{"location":"Sistemas%20Embebidos/8comunicacionuart/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Comunicacion uart y usb </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 22/10/25 </li> <li>Descripci\u00f3n breve: _En equipos de 4 conectar dos picos por medio de rx y tx bidireccional para intercambiar mensajes escritos en la consolas de las computadoras. _</li> </ul>"},{"location":"Sistemas%20Embebidos/8comunicacionuart/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Aprender las utilidades del PWM</li> <li>Espec\u00edficos:</li> <li>Desensamblar y ensamblar strings sin que se corrompan los mensajes_</li> <li>Utilizar frecuencias espec\u00edficas para hacer notas musicales</li> <li>Crear una se\u00f1al sinusoidal a parir de una PWM y un filtro con capacitor y leerla con un osciloscopio</li> </ul>"},{"location":"Sistemas%20Embebidos/8comunicacionuart/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>1 capacitor de 1uF, resistencias de 1k y 680 ohms, osciloscopio   -1 buzzer pasivo, 1 resistencia de 220.   -2 botones, resistencias pulldown de 1k, 1 motor DC._</li> </ul>"},{"location":"Sistemas%20Embebidos/8comunicacionuart/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/8comunicacionuart/#5-codigos","title":"5) C\u00f3digos","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 17\n#define led_PIN 16\nusing namespace std; //USO DE STRING en la terminal \n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART); // DEFINE TX Y RX\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE); //VELOCIDAD DE TRANSMISI\u00d3N, \n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE); //NO QUEREMOS ENCONTRAR ERRORES DE TRANSMISI\u00d3N, para saber como empieza el msj\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    string c = \"\"; // DEFINE C Y P COMO VARIIABLE DE RECONSTRUCCION, C LA RECIBE LA PALABRA  \n    string p=\"\"; //RECONSTRUYE LA PALABRA QUE VAMOS A ENVIAR\n    while (true){\n\n        int ch = getchar_timeout_us(0); //LEE EL CARACTER\n        if (ch != PICO_ERROR_TIMEOUT) { //SI NO HAY ERROR, ENTONCES IMPRIME EL CARACTER\n            printf(\"Eco: %c\\n\", (char)ch); //IMPRIME EL CARACTER DE LA PALABRA RECIBIDA, \n            p+= (char)ch; //RECONSTRUYE LA PALABRA EN P\n\n            if(ch=='.' || ch=='\\n'){ // CUANDO ENTRA UN PUNTO O UN ENTER \n                uart_puts(UART_ID, p.c_str()); //MANDA LA PALABRA P, AL OTRO PICO, CONVIERTE UN STRING EN UN ARREGLO DE CARACTERES\n                p=\"\"; //VACIAMOS LA PALBRA P, PARA ENVIAR UNA NUEVA\n            }\n        }\n        int a;\n        if (gpio_get(button_pin) == 0 &amp;&amp; a == 1) {\n            printf(\"Button pressed!\\n\");//HACE QUE FUNCIONE EL BOTON CUANDO SE PRESIONA\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200); \n        }\n         a= gpio_get(button_pin); //TOMA EL VALOR DEL BOTON PIN\n\n        if (uart_is_readable(uart0)) { //SI HAY DATOS PARA LEER\n            char character = uart_getc(uart0); //LEE EL CARACTER\n            printf(character+\"\\n\"); //IMPRIME EL CARACTER RECIBIDO\n\n            if(character=='\\n' || character=='.'){ //CUANDO ENTRA UN PUNTO O UN ENTER\n                if (c == \"LEDON\"){\n                    gpio_put(led_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\"){\n                    gpio_put(led_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n\n                } \n                else if (c == \"Invalid Command\"){\n                    printf(\"Invalid Command\\n\");\n\n                }\n                else{\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c = \"\";\n                continue;\n            }\n            else{\n                c += character;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/examen2/","title":"Examen servo","text":""},{"location":"Sistemas%20Embebidos/examen2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cctype&gt;\n\n#define SERVO_PIN 15\n#define BTN_MODE 2\n#define BTN_NEXT 3\n#define BTN_PREV 4\n\nusing namespace std;\n\n// --- Variables globales ---\nvector&lt;int&gt; posiciones;\nint indice_actual = 0;\nvolatile int modo_actual = 1;\nvolatile bool ciclo_activo = false;\n\n// --- Funciones auxiliares ---\nbool es_numero(const string&amp; str) {\n    if (str.empty()) return false;\n    for (char c : str) {\n        if (!isdigit(c) &amp;&amp; c != '-') return false;\n    }\n    return true;\n}\n\nint string_a_int(const string&amp; str) {\n    int resultado = 0;\n    int signo = 1;\n    size_t inicio = 0;\n\n    if (str[0] == '-') {\n        signo = -1;\n        inicio = 1;\n    }\n\n    for (size_t i = inicio; i &lt; str.length(); i++) {\n        if (isdigit(str[i])) {\n            resultado = resultado * 10 + (str[i] - '0');\n        } else {\n            return -9999;\n        }\n    }\n\n    return resultado * signo;\n}\n\nvoid mostrar_bienvenida() {\n    printf(\"\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"    SISTEMA DE CONTROL DE SERVO\\n\");\n    printf(\"         Raspberry Pi Pico\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"Modos disponibles:\\n\");\n    printf(\"  1 - Entrenamiento\\n\");\n    printf(\"  2 - Continuo\\n\");\n    printf(\"  3 - Step\\n\");\n    printf(\"\\n\");\n    printf(\"Comandos disponibles:\\n\");\n    printf(\"  escribir, write - Guardar posiciones\\n\");\n    printf(\"  borrar, clear   - Borrar lista\\n\");\n    printf(\"  reemplazar, replace - Modificar posicion\\n\");\n    printf(\"  help, ayuda     - Mostrar este mensaje\\n\");\n    printf(\"\\n\");\n    printf(\"Presiona BTN_MODE para cambiar modos\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"\\n\");\n}\n\nvoid borrar_lista() {\n    posiciones.clear();\n    indice_actual = 0;\n    printf(\"OK\\n\");\n}\n\nuint16_t angle_to_level(uint16_t angle) {\n    // Para servo est\u00e1ndar: 0\u00b0 = 1000us, 180\u00b0 = 2000us\n    float min_pulse_us = 1000.0f;   // 0 grados\n    float max_pulse_us = 2000.0f;   // 180 grados  \n    float period_us = 20000.0f;     // Periodo de 20ms (50Hz)\n\n    // Calcular pulso para el \u00e1ngulo\n    float pulse_us = min_pulse_us + (angle * (max_pulse_us - min_pulse_us) / 180.0f);\n\n    // Convertir a nivel PWM\n    return (uint16_t)((pulse_us / period_us) * 65535.0f);\n}\n\nvoid mover_servo(uint slice, uint chan, int ang) {\n    if (ang &lt; 0) ang = 0;\n    if (ang &gt; 180) ang = 180;\n    pwm_set_chan_level(slice, chan, angle_to_level(ang));\n}\n\n// Interrupci\u00f3n para cambiar modo\nvoid gpio_callback(uint gpio, uint32_t events) {\n    if (gpio == BTN_MODE) {\n        modo_actual++;\n        if (modo_actual &gt; 3) modo_actual = 1;\n        ciclo_activo = (modo_actual == 2);\n\n        printf(\"\\n=== Modo cambiado ===\\n\");\n        switch(modo_actual) {\n            case 1: printf(\"MODO ENTRENAMIENTO activado\\n\"); break;\n            case 2: printf(\"MODO CONTINUO activado\\n\"); break;\n            case 3: printf(\"MODO STEP activado\\n\"); break;\n        }\n        printf(\"=====================\\n\");\n\n        if (!posiciones.empty()) {\n            indice_actual = 0;\n        }\n    }\n}\n\n// Procesar comando de consola\nvoid procesar_comando(const string&amp; cmd, uint slice, uint chan) {\n    string cmd_lower = cmd;\n    for (char &amp;c : cmd_lower) c = tolower(c);\n\n    if (cmd_lower == \"write\" || cmd_lower == \"escribir\"|| cmd_lower == \"Escribir\") {\n        printf(\"Ingresa valores separados por comas (ej: 0,90,130): \");\n\n        string entrada = \"\";\n        absolute_time_t timeout = make_timeout_time_ms(10000);\n\n        while (true) {\n            int c = getchar_timeout_us(100000);\n            if (c != PICO_ERROR_TIMEOUT) {\n                if (c == '\\n' || c == '\\r') break;\n                entrada += (char)c;\n                printf(\"%c\", c);\n            }\n            if (time_reached(timeout)) {\n                printf(\"\\nError: timeout en entrada\\n\");\n                return;\n            }\n        }\n        printf(\"\\n\");\n\n        if (entrada.empty()) {\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        vector&lt;int&gt; temp_pos;\n        string temp = \"\";\n\n        for (char c : entrada) {\n            if (c == ',') {\n                if (!temp.empty()) {\n                    if (!es_numero(temp)) {\n                        printf(\"Error argumento invalido\\n\");\n                        return;\n                    }\n                    int val = string_a_int(temp);\n                    if (val &lt; 0 || val &gt; 180) {\n                        printf(\"Error argumento invalido\\n\");\n                        return;\n                    }\n                    temp_pos.push_back(val);\n                    temp = \"\";\n                }\n            } else if (c != ' ') {\n                temp += c;\n            }\n        }\n\n        if (!temp.empty()) {\n            if (!es_numero(temp)) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            int val = string_a_int(temp);\n            if (val &lt; 0 || val &gt; 180) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            temp_pos.push_back(val);\n        }\n\n        if (temp_pos.empty()) {\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        posiciones = temp_pos;\n        indice_actual = 0;\n        printf(\"OK - %d posiciones guardadas: \", (int)posiciones.size());\n        for (size_t i = 0; i &lt; posiciones.size(); i++) {\n            printf(\"%d\", posiciones[i]);\n            if (i &lt; posiciones.size() - 1) printf(\", \");\n        }\n        printf(\"\\n\");\n\n    } else if (cmd_lower == \"clear\" || cmd_lower == \"borrar\"||cmd_lower == \"Borrar\") {\n        borrar_lista();\n\n    } else if (cmd_lower == \"replace\" || cmd_lower == \"reemplazar\"|| cmd_lower == \"Reemplazar\") {\n        printf(\"Ingresa posicion,valor (ej: 1,130): \");\n        string entrada = \"\";\n        absolute_time_t timeout = make_timeout_time_ms(10000);\n\n        while (true) {\n            int c = getchar_timeout_us(100000);\n            if (c != PICO_ERROR_TIMEOUT) {\n                if (c == '\\n' || c == '\\r') break;\n                entrada += (char)c;\n                printf(\"%c\", c);\n            }\n            if (time_reached(timeout)) {\n                printf(\"\\nError: timeout en entrada\\n\");\n                return;\n            }\n        }\n        printf(\"\\n\");\n\n        if (entrada.empty()) {\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        int pos = -1, val = -1;\n        string temp = \"\";\n        bool sep = false;\n\n        for (char c : entrada) {\n            if (c == ',' &amp;&amp; !sep) {\n                if (!es_numero(temp)) {\n                    printf(\"Error argumento invalido\\n\");\n                    return;\n                }\n                pos = string_a_int(temp) - 1;\n                if (pos == -10000) {\n                    printf(\"Error argumento invalido\\n\");\n                    return;\n                }\n                temp = \"\";\n                sep = true;\n            } else if (c != ' ') {\n                temp += c;\n            }\n        }\n\n        if (sep &amp;&amp; !temp.empty()) {\n            if (!es_numero(temp)) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            val = string_a_int(temp);\n            if (val == -9999) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n        }\n\n        if (pos &lt; 0 || pos &gt;= (int)posiciones.size()) {\n            printf(\"Error indice invalido\\n\");\n        } else if (val &lt; 0 || val &gt; 180) {\n            printf(\"Error argumento invalido\\n\");\n        } else {\n            posiciones[pos] = val;\n            printf(\"OK - Posicion %d actualizada a %d grados\\n\", pos + 1, val);\n        }\n\n    } else if (cmd_lower == \"help\" || cmd_lower == \"ayuda\" || cmd_lower == \"?\") {\n        mostrar_bienvenida();\n\n    } else {\n        printf(\"Comando no reconocido: '%s'\\n\", cmd.c_str());\n         printf(\"Escribe 'help' para ver comandos disponibles\\n\");\n    }\n}\n\n// --- Programa principal ---\nint main() {\n    // Inicializar USB serial\n    stdio_init_all();\n\n    // Esperar a que se conecte el monitor serial\n    sleep_ms(3000);\n\n    // Mostrar mensaje de bienvenida\n    mostrar_bienvenida();\n    printf(\"Sistema inicializado. Esperando comandos...\\n\");\n    printf(\"&gt; \");\n\n\n    // Configurar PWM para servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan = pwm_gpio_to_channel(SERVO_PIN);\n    pwm_set_wrap(slice, 65535);\n\n    // Configurar el divisor para 50Hz\n    float div = 125.0f / (50.0f * 65535.0f / 1000000.0f);\n    pwm_set_clkdiv(slice, div);\n\n    pwm_set_enabled(slice, true);\n\n    // Configurar botones\n    gpio_init(BTN_MODE);\n    gpio_set_dir(BTN_MODE, GPIO_IN);\n    gpio_pull_up(BTN_MODE);\n\n    gpio_init(BTN_NEXT);\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    gpio_init(BTN_PREV);\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    // Configurar interrupci\u00f3n para BTN_MODE\n    gpio_set_irq_enabled(BTN_MODE, GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_callback(gpio_callback);\n    irq_set_enabled(IO_IRQ_BANK0, true);\n\n    string mensaje_usb = \"\";\n    bool btn_next_prev = false;\n    bool btn_prev_prev = false;\n\n    while (true) {\n        // Leer comandos por USB\n        int ch = getchar_timeout_us(1000);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    procesar_comando(mensaje_usb, slice, chan);\n                    mensaje_usb = \"\";\n                    printf(\"&gt; \");\n                }\n            } else {\n                mensaje_usb += (char)ch;\n            }\n        }\n\n        // Modo Step\n        if (modo_actual == 3) {\n            bool btn_next_actual = !gpio_get(BTN_NEXT);\n            bool btn_prev_actual = !gpio_get(BTN_PREV);\n\n            if (btn_next_actual &amp;&amp; !btn_next_prev) {\n                if (posiciones.empty()) {\n                    printf(\"Error no hay pos\\n\");\n                } else {\n                    if (indice_actual &lt; (int)posiciones.size() - 1) {\n                        indice_actual++;\n                    }\n                    mover_servo(slice, chan, posiciones[indice_actual]);\n                    printf(\"pos%d: %d\\n\", indice_actual + 1, posiciones[indice_actual]);\n                }\n            }\n\n            if (btn_prev_actual &amp;&amp; !btn_prev_prev) {\n                if (posiciones.empty()) {\n                    printf(\"Error no hay pos\\n\");\n                } else {\n                    if (indice_actual &gt; 0) {\n                        indice_actual--;\n                    }\n                    mover_servo(slice, chan, posiciones[indice_actual]);\n                    printf(\"pos%d: %d\\n\", indice_actual + 1, posiciones[indice_actual]);\n                }\n            }\n\n            btn_next_prev = btn_next_actual;\n            btn_prev_prev = btn_prev_actual;\n        }\n\n        // Modo Continuo\n        if (modo_actual == 2 &amp;&amp; ciclo_activo) {\n            if (posiciones.empty()) {\n                printf(\"Error no hay pos\\n\");\n                sleep_ms(1500);\n            } else {\n                for (int i = 0; i &lt; (int)posiciones.size(); i++) {\n                    if (!ciclo_activo) break;\n\n                    mover_servo(slice, chan, posiciones[i]);\n                    printf(\"pos%d: %d\\n\", i + 1, posiciones[i]);\n\n                    absolute_time_t start_time = get_absolute_time();\n                    while (absolute_time_diff_us(start_time, get_absolute_time()) &lt; 1500000) {\n                        sleep_ms(100);\n                        if (!ciclo_activo) break;\n                    }\n                }\n            }\n        }\n\n        // Modo Entrenamiento\n        if (modo_actual == 1 &amp;&amp; !posiciones.empty()) {\n            bool btn_next_actual = !gpio_get(BTN_NEXT);\n            bool btn_prev_actual = !gpio_get(BTN_PREV);\n\n            if (btn_next_actual &amp;&amp; !btn_next_prev) {\n                if (indice_actual &lt; (int)posiciones.size() - 1) {\n                    indice_actual++;\n                }\n                mover_servo(slice, chan, posiciones[indice_actual]);\n                printf(\"Servo a %d\u00b0 (pos%d)\\n\", posiciones[indice_actual], indice_actual + 1);\n            }\n\n            if (btn_prev_actual &amp;&amp; !btn_prev_prev) {\n                if (indice_actual &gt; 0) {\n                    indice_actual--;\n                }\n                mover_servo(slice, chan, posiciones[indice_actual]);\n                printf(\"Servo a %d\u00b0 (pos%d)\\n\", posiciones[indice_actual], indice_actual + 1);\n            }\n\n            btn_next_prev = btn_next_actual;\n            btn_prev_prev = btn_prev_actual;\n        }\n\n        sleep_ms(10);\n    }\n\n    return 0;\n}\n</code></pre>"}]}